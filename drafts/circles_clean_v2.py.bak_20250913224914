
"""
circles_clean_v2.py
===================
Clean circles→thermal clustering with an uncluttered plot.

- Detect circles by cumulative heading ≥ 300° (scratch2-style), light smoothing (3 s).
- Cluster circles allowing drift (EPS meters, GAP seconds).
- Plot only:
    * Track = green
    * Circles = green ✕ (midpoints)
    * Cluster centers = black ✕
  **No labels** drawn on the map (identifiers are in CSVs).

Outputs (./outputs):
  - circles_turns_<ts>.csv
  - circles_clusters_<ts>.csv
  - circles_cluster_pairs_<ts>.csv
  - circles_clean_<ts>.txt  (console tee)
"""

import sys, math, datetime
from pathlib import Path
from typing import List, Tuple

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from igc_utils import parse_igc, compute_derived, detect_tow_segment

# ---------------- Tunables ----------------
MIN_ARC_DEG = 300.0          # cumulative heading threshold (deg)
HEADING_SMOOTH_S = 3.0       # seconds of heading smoothing
MAX_LEN_SAMPLES = 1000       # safety cap on circle window

EPS_M = 1500.0               # meters — spatial drift allowed when clustering
MAX_GAP_S = 900.0            # seconds — temporal bridge allowed when clustering
MIN_CLUSTER_COUNT = 1        # keep singletons for now

# ---------------- Helpers ----------------
R_EARTH_M = 6371000.0

class Tee:
    def __init__(self, *files): self.files = files
    def write(self, obj):
        for f in self.files: f.write(obj); f.flush()
    def flush(self):
        for f in self.files: f.flush()

def haversine_m(lat1, lon1, lat2, lon2):
    lat1, lon1, lat2, lon2 = map(np.radians, [lat1, lon1, lat2, lon2])
    dlat, dlon = lat2 - lat1, lon2 - lon1
    a = np.sin(dlat/2)**2 + np.cos(lat1)*np.cos(lat2)*np.sin(dlon/2)**2
    return 2*R_EARTH_M*np.arcsin(np.sqrt(a))

def ensure_time_sec(df: pd.DataFrame) -> pd.DataFrame:
    df = df.copy()
    if not np.issubdtype(df['time'].dtype, np.datetime64):
        df['time'] = pd.to_datetime(df['time'], errors='coerce')
    if 'sec' not in df.columns:
        df['sec'] = (df['time'] - df['time'].iloc[0]).dt.total_seconds().astype(float)
    return df

def sec_per_fix(df: pd.DataFrame) -> float:
    ds = df['sec'].diff().dropna()
    dt = float(ds.median()) if len(ds) else 1.0
    if not np.isfinite(dt) or dt <= 0: dt = 1.0
    return dt

def smooth_series(x: pd.Series, seconds: float, dt_fix: float) -> pd.Series:
    if seconds <= 0: return x.copy()
    w = max(3, int(round(seconds / max(dt_fix, 1e-6))))
    if w % 2 == 0: w += 1
    return x.rolling(window=w, center=True, min_periods=max(1, w//2)).mean()

def bearing_deg(lat1, lon1, lat2, lon2):
    lat1 = math.radians(lat1); lon1 = math.radians(lon1)
    lat2 = math.radians(lat2); lon2 = math.radians(lon2)
    dlon = lon2 - lon1
    x = math.sin(dlon) * math.cos(lat2)
    y = math.cos(lat1)*math.sin(lat2) - math.sin(lat1)*math.cos(lat2)*math.cos(dlon)
    return (math.degrees(math.atan2(x, y)) + 360.0) % 360.0

def circ_diff_deg(a, b):  # signed smallest difference b-a in (-180,180]
    return (b - a + 540.0) % 360.0 - 180.0

# ---------------- Circle detection ----------------
def detect_circles(df: pd.DataFrame,
                   min_circle_heading_deg: float = MIN_ARC_DEG,
                   max_len_samples: int = MAX_LEN_SAMPLES,
                   smooth_s: float = HEADING_SMOOTH_S):
    """
    Return: circles list[(start_idx, end_idx, arc_deg)], cadence_sec_per_fix
    """
    df = ensure_time_sec(df)
    dt = sec_per_fix(df)

    # headings (light smoothing)
    headings = [0.0]
    for i in range(1, len(df)):
        headings.append(bearing_deg(df.loc[i-1,'lat'], df.loc[i-1,'lon'],
                                    df.loc[i,'lat'], df.loc[i,'lon']))
    hdg = pd.Series(headings)
    hdg_s = smooth_series(hdg, smooth_s, dt).to_numpy()

    circles = []
    n = len(df)
    i = 0
    while i < n-2:
        cum = 0.0
        j = i + 1
        last_h = hdg_s[i]
        while j < n and (j - i) < max_len_samples:
            now_h = hdg_s[j]
            d = circ_diff_deg(last_h, now_h)
            cum += d
            last_h = now_h
            if abs(cum) >= min_circle_heading_deg:
                circles.append((i, j, cum))
                i = j + 1
                break
            j += 1
        else:
            i += 1
    return circles, dt

# ---------------- Circles → clusters ----------------
def circles_to_dataframe(df: pd.DataFrame, circles):
    rows = []
    for k, (s, e, arc) in enumerate(circles, start=1):
        mid = (s + e) // 2
        dur = float(df['sec'].iloc[e] - df['sec'].iloc[s])
        chord_m = haversine_m(df['lat'].iloc[s], df['lon'].iloc[s],
                              df['lat'].iloc[e], df['lon'].iloc[e])
        radius_est = max(chord_m / max(np.radians(abs(arc)), 1e-6), 1.0)
        rows.append({
            "circle_id": k,
            "start_idx": int(s), "end_idx": int(e),
            "start_time": df["time"].iloc[s], "end_time": df["time"].iloc[e],
            "duration_s": dur, "arc_deg": float(abs(arc)),
            "turn_rate_deg_s": float(arc / max(dur, 1e-6)),
            "radius_m_est": float(radius_est),
            "lat_mid": float(df["lat"].iloc[mid]), "lon_mid": float(df["lon"].iloc[mid]),
        })
    cols = ["circle_id","start_idx","end_idx","start_time","end_time","duration_s",
            "arc_deg","turn_rate_deg_s","radius_m_est","lat_mid","lon_mid"]
    return pd.DataFrame(rows, columns=cols)

def clusters_from_circles(circles_df: pd.DataFrame, eps_m: float = EPS_M, max_gap_s: float = MAX_GAP_S):
    if circles_df.empty:
        return circles_df.assign(cluster_id=[]), pd.DataFrame(columns=[
            "cluster_id","n","start_time","end_time","mean_radius_m","center_lat","center_lon"
        ])

    df = circles_df.reset_index(drop=True)
    n = len(df)
    lats = df["lat_mid"].to_numpy(float)
    lons = df["lon_mid"].to_numpy(float)
    t0 = pd.to_datetime(df["start_time"]).to_numpy()
    t1 = pd.to_datetime(df["end_time"]).to_numpy()
    radius = df["radius_m_est"].to_numpy(float)

    # distances
    dist = np.zeros((n, n), dtype=float)
    for i in range(n):
        for j in range(i+1, n):
            d = float(haversine_m(lats[i], lons[i], lats[j], lons[j]))
            dist[i, j] = dist[j, i] = d

    # adjacency by space+time proximity
    adj = [[] for _ in range(n)]
    for i in range(n):
        for j in range(i+1, n):
            spatial_ok = dist[i, j] <= eps_m
            gap_ij = max(0.0, (pd.to_datetime(t0[j]) - pd.to_datetime(t1[i])).total_seconds())
            gap_ji = max(0.0, (pd.to_datetime(t0[i]) - pd.to_datetime(t1[j])).total_seconds())
            temporal_ok = (gap_ij <= max_gap_s) or (gap_ji <= max_gap_s) or \
                          (pd.to_datetime(t1[i]) >= pd.to_datetime(t0[j])) or \
                          (pd.to_datetime(t1[j]) >= pd.to_datetime(t0[i]))
            if spatial_ok and temporal_ok:
                adj[i].append(j); adj[j].append(i)

    # components
    visited = np.zeros(n, dtype=bool)
    comp_id = np.full(n, -1, dtype=int)
    clusters = []
    cid = 0
    for i in range(n):
        if visited[i]: continue
        q = [i]; visited[i] = True; members = []
        while q:
            k = q.pop(0); members.append(k)
            for j in adj[k]:
                if not visited[j]:
                    visited[j] = True; q.append(j)
        idx = np.array(members, int)
        w = np.clip(1.0 / np.maximum(radius[idx], 1.0), 0.1, None)  # tighter radius weighs more
        lat_c = float(np.average(lats[idx], weights=w))
        lon_c = float(np.average(lons[idx], weights=w))
        mean_r = float(np.mean(radius[idx])) if len(idx) else float('nan')
        start_time = pd.to_datetime(t0[idx].min()).to_pydatetime()
        end_time   = pd.to_datetime(t1[idx].max()).to_pydatetime()
        clusters.append({
            "cluster_id": cid+1, "n": int(len(idx)),
            "start_time": start_time, "end_time": end_time,
            "mean_radius_m": mean_r, "center_lat": lat_c, "center_lon": lon_c,
        })
        comp_id[idx] = cid+1; cid += 1

    clusters_df = pd.DataFrame(clusters, columns=[
        "cluster_id","n","start_time","end_time","mean_radius_m","center_lat","center_lon"
    ])
    df_with_cluster = df.copy(); df_with_cluster["cluster_id"] = comp_id
    return df_with_cluster, clusters_df

def successive_cluster_pairs(clusters_df: pd.DataFrame) -> pd.DataFrame:
    if clusters_df.empty or len(clusters_df) == 1:
        return pd.DataFrame(columns=[
            "from_id","to_id","gap_minutes","distance_km","implied_kmh",
            "from_end","to_start","from_lat","from_lon","to_lat","to_lon"
        ])
    df = clusters_df.sort_values("start_time").reset_index(drop=True)
    rows = []
    for i in range(len(df)-1):
        a = df.iloc[i]; b = df.iloc[i+1]
        gap_s = (b["start_time"] - a["end_time"]).total_seconds()
        d_m = haversine_m(a["center_lat"], a["center_lon"], b["center_lat"], b["center_lon"])
        rows.append({
            "from_id": int(a["cluster_id"]), "to_id": int(b["cluster_id"]),
            "gap_minutes": round(gap_s/60.0, 1),
            "distance_km": round(d_m/1000.0, 2),
            "implied_kmh": round((d_m/1000.0)/(gap_s/3600.0), 1) if gap_s>0 else None,
            "from_end": a["end_time"], "to_start": b["start_time"],
            "from_lat": a["center_lat"], "from_lon": a["center_lon"],
            "to_lat": b["center_lat"], "to_lon": b["center_lon"],
        })
    return pd.DataFrame(rows)

# ---------------- Plot (NO LABELS) ----------------
def params_box_text(dt):
    return (
        f"Cadence: {dt:.2f} s/fix\\n"
        f"Circle: arc≥{int(MIN_ARC_DEG)}°, smooth={int(HEADING_SMOOTH_S)} s, max_win≤{MAX_LEN_SAMPLES} samples\\n"
        f"Cluster: eps={int(EPS_M)} m, gap≤{int(MAX_GAP_S/60)} min"
    )

def add_params_box(ax, dt):
    ax.text(0.99, 0.01, params_box_text(dt), transform=ax.transAxes, va='bottom', ha='right',
            fontsize=9, family='monospace',
            bbox=dict(boxstyle="round,pad=0.35", facecolor="white", alpha=0.85, lw=0.5))

def plot_map(df: pd.DataFrame, circles, clusters_df: pd.DataFrame, dt: float):
    fig, ax = plt.subplots(figsize=(10.5, 7.2))
    # Track
    ax.plot(df["lon"], df["lat"], color="green", lw=1.2, alpha=0.7, label="Track")
    # Circles
    mids_lon, mids_lat = [], []
    for (s,e,_) in circles:
        m = (s+e)//2
        mids_lon.append(float(df["lon"].iloc[m])); mids_lat.append(float(df["lat"].iloc[m]))
    if mids_lon:
        ax.scatter(mids_lon, mids_lat, marker='x', c='green', s=40, linewidths=1.6, zorder=5, label="Circles")
    # Cluster centers (no labels)
    big = clusters_df[clusters_df["n"] >= MIN_CLUSTER_COUNT]
    if not big.empty:
        ax.scatter(big["center_lon"], big["center_lat"], marker='x', c='k', s=110, linewidths=1.8, zorder=6)
    add_params_box(ax, dt)
    ax.set_title("Circles → Thermals (Track=green, Circles=green ✕, Centers=black ✕) — No labels")
    ax.set_xlabel("Longitude"); ax.set_ylabel("Latitude")
    ax.legend(loc='upper left'); ax.grid(True, alpha=0.3)
    plt.tight_layout(); plt.show()

# ---------------- Main ----------------
def main():
    ts = datetime.datetime.now().strftime("%y%m%d%H%M%S")
    logf = open(f"circles_clean_{ts}.txt", "w")
    sys.stdout = sys.stderr = Tee(sys.stdout, logf)

    igc_file = "../2020-11-08 Lumpy Paterson 108645.igc"
    print(f"[circles-clean v2] Parsing IGC: {igc_file}")
    df = parse_igc(igc_file)
    if df.empty:
        print("[circles-clean v2] No rows parsed; aborting."); return
    df = compute_derived(df); df = ensure_time_sec(df)

    try:
        tow = detect_tow_segment(df)
    except Exception as e:
        print(f"[circles-clean v2] Tow detect error: {e}"); tow = None
    if isinstance(tow, tuple) and len(tow) == 2:
        s,e = tow
        print(f"[circles-clean v2] Tow detected: {s}→{e}. Excluding tow.")
        df = df.iloc[e+1:].reset_index(drop=True); df = ensure_time_sec(df)
    else:
        print("[circles-clean v2] Tow not clearly detected; using full trace.")
    print(f"[circles-clean v2] Points after tow trim: {len(df)}")

    circles, dt = detect_circles(df, MIN_ARC_DEG, MAX_LEN_SAMPLES, HEADING_SMOOTH_S)
    print(f"[circles-clean v2] Cadence ≈ {dt:.2f} s/fix | circles detected: {len(circles)}")

    circ_df = circles_to_dataframe(df, circles)
    circ_with_cluster, clusters_df = clusters_from_circles(circ_df, EPS_M, MAX_GAP_S)
    pairs_df = successive_cluster_pairs(clusters_df)

    out = Path("../outputs"); out.mkdir(parents=True, exist_ok=True)
    f1 = out / f"circles_turns_{ts}.csv"; circ_with_cluster.to_csv(f1, index=False)
    f2 = out / f"circles_clusters_{ts}.csv"; clusters_df.to_csv(f2, index=False)
    f3 = out / f"circles_cluster_pairs_{ts}.csv"; pairs_df.to_csv(f3, index=False)
    print(f"[circles-clean v2] Wrote CSVs to ./outputs: {f1.name}, {f2.name}, {f3.name}")

    plot_map(df, circles, clusters_df, dt)

if __name__ == "__main__":
    main()
